###### 定义实体类对象的规则

## oracle 处理空数据

###### 当使用空字符串为条件查询时
```sql
 select * from tableName
 where
    (rid is null or rid ='')
```
##### 但是如果以非空字符串查询
```sql
select * from tableName
where 
	(rid not in
		(select rid from table2Name
			where 
				(parentId is null or parentId = '') 
		)
	)
```
基本逻辑为：
1. 优先查询为空的结果集，再从结果集中做排除，

!> 上述语句问题在于：性能上有了一部分损失，且使用了in操作符

但是如果有条件看可以获取所连接的数据库类型(在utils模块定义了：获取数据库类型的方法)

```java
DatabaseUtils.getDataSourceType("数据库驱动配置名")
```

则可以在生成sql语句的时候，通过数据库类型来兼容Oracle与mysql
* 当数据库为Oracle时，使用上述复杂查询，
* 当数据库为mysql时，使用下面的简单方式即可，

你可以使用拼接sql语句的方式：
```java
Boolean isOracle = DatabaseUtil.DBTYPE_ORACLE.equals(DatabaseUtil.getDataSourceType())
String sql = "select * from tableName"
+ "where"
	+ "(rid is not null"
	+ isOracle ? "and rid <.......此处为你的oracle语法>)":")"
```
你也可以使用封装方法

```javascript
String sql="select * from organinfo where "+DatabaseFunc.defaultDatabaseFunc().notNullCharWhere("PARENTID");
```

###### 为什么Oracle不可简单的写成下面的语句？
```sql
	## 错误写法
	select * from tableName 
	where
		rid is not null and rid = ''
```
!> 因为 Oracle数据库没有空字符串值，声明了的 `''` 会被视为null，上述的sql语句就会变为：
```sql
	select * from tableName 
	where 
		rid is not null and rid = null
```
?> 此sql语句不会查询到任何数据。

## 统一SQL函数
* @Query
* 生成sql语句：String sql = 'select * from tableName'

无论使用上述何种方法，在sql语句中均不可使用：
* SQL函数
* 字符串链接
* 空empty字符串
因为不同数据库，sql函数名往往不相同，少量常用SQL函数可以封装到Utils模块的DatabaseFunc类中(`内部实现根据数据库来动态处理`)。

## 通过
通过原生SQL语句查询数据，因社会到实体对象的时候，不同的数据库，语句中对于字段名称大小的处理策略是不一致的。

|数据库|处理策略|建议|
|-----|--------|---|
|oracle|默认全部大写|写大写|

所以，我们如果要想要原生的sql语句支持不同的数据库，就需要提供根据不同的数据库来处理语句中可能会变化的命名。
```text
String sql = "select a.RID as RID,a.code as CODE,a.PCODE as PCODE,a.CREATEDATE as CREATEDATE,a.USERID as USERID,"+
				"a.WFRID as WFRID,a.INITFORM as INITFORM,a.JTITLE as TITLE,a.BWEBQUERY as BWEBQUERY,a.SORTVALUE as SORTVALUE,"+
				"b.NAME_ as WFRIDTXT,c.TITLE as INITFORMTXT"
				+ " from BUSINESSDEF a left join ACT_RE_PROCDEF b on a.WFRID=b.ID_ LEFT JOIN FORMINFO c on a.INITFORM=c.RID ";
		SQLQuery query = session.createSQLQuery(sql);
		//为了兼容，按以下方式与sql语句中的字段顺序指定别名，且非字符串类型，需要指定具体类型(否则可能转换会出错)
		query.addScalar("rid").addScalar("code").addScalar("pcode")
			.addScalar("createDate").addScalar("userId")
			.addScalar("wfRID").addScalar("initForm").addScalar("title")
			.addScalar("bwebQuery",StandardBasicTypes.INTEGER).addScalar("sortValue",StandardBasicTypes.INTEGER)
			.addScalar("wfRIDTxt").addScalar("initFormTxt");
		query.setResultTransformer(Transformers.aliasToBean(BusinessDefData.class));
		List<BusinessDefData> data=query.list();
```
