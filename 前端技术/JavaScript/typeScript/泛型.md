# 泛型

## 泛型方法

#### 声明泛型

```typescript
function generics_func1<T>(arg: T): T {
    return arg;
}
// 或者
let generics_func2: <T>(arg: T) => T = function (arg) {
    return arg;
}
```

#### 调用方法

```typescript
generics_func1<string>('Hello world');
// 或者
generics_func2('Hello world');
```
`注：第二种调用方式可以省略类型参数，因为编译器会根据传入参数来自动识别对应的类型。`

#### 类似泛型，但又不是泛型

```typescript
// 方法一：带有any参数的方法
function any_func(arg: any): any {
    console.log(arg.length);
    return arg;
}

// 方法二：Array泛型方法
function array_func<T>(arg: Array<T>): Array<T> {
    console.log(arg.length);
    return arg;
}
```
在方法一的方法体里，打印了arg参数的length属性。因为`any`可以代替任意类型，
所以该方法在传入参数不是数组或者带有length属性对象时，会抛出异常。
而方法二定义了参数类型是`Array`的泛型类型，肯定会有length属性，所以不会抛出异常。

从上面这个例子可以看出，泛型类型相比较any类型来说，在某些情况下会带有类型本身的一些信息，而any类型则没有。

## 泛型类

#### 泛型类的定义和调用

```typescript
class Generics_Demo<T>{
    value: T;
    show(): T {
        return this.value;
    }
}

let gene_demo1 = new Generics_Demo<number>();
gene_demo1.value = 1;
console.log(gene_demo1.show());                                     // 调用方法

gene_demo1.show = function () { return gene_demo1.value + 1; }      // 赋值新方法，返回值类型必须是number
console.log(gene_demo1.show());
```
通过指定明确类型的泛型类的实例，对属性赋值时，必须满足实际类型的约束。

## 泛型类型

- 泛型接口
    - 下面的例子里，接口只有一个泛型方法成员。则用此接口类型定义的变量就是一个与成员类型一致的泛型方法。
    ```typescript
    interface Generics_interface {
        <T>(arg: T): T;
    }
    
    function func_demo<T>(arg: T): T {
        return arg;
    }
    
    let func1: Generics_interface = func_demo;
    ```
    
    - 通过在接口上声明泛型，声明变量时明确指定泛型的具体类型，则赋值的方法将自动带上具体的类型约束。
    ```typescript
    interface Generics_interface<T> {
        (arg: T): T;
    }
    
    function func_demo<T>(arg: T): T {
        return arg;
    }
    
    let func1: Generics_interface<number> = func_demo;
    func1(123);     // 正确类型的实际参数
    func1('123');   // 错误类型的实际参数
    ```

- 泛型类型继承
    - 下面的例子里，泛型类型继承自一个拥有length属性成员的接口，泛型类型将自动加上length属性的约束。
    调用时只有符合条件的对象才能正确赋值。
    ```typescript
    interface LengthInterface {
        length: number;
    }
    
    function func_demo<T extends LengthInterface>(arg: T): T {
        console.log(arg.length);
        return arg;
    }
    
    func_demo({ a: 1, length: 2 });     // 含有length属性的对象
    func_demo([1, 2]);                  // 数组类型
    ```
    
    - 在下面的例子里，一个泛型类型继承自另外一个泛型类型。
    在方法调用时，就必须确保继承类型对应的参数对象属性完全包含被继承类型对应的参数对象。
    ```typescript
    function copy<T extends U, U>(source: U, target: T): T {
        for (let prop in source) {
            target[prop] = source[prop];
        }
    
        return target;
    }
    
    copy({ a: 1, b: 2 }, { a: 2, b: 3, c: 4 });         // 正确的实际参数
    copy({ a: 1, b: 2 }, { q: 2, c: 4 });               // 错误的实际参数
    ```




