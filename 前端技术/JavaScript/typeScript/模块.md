# 模块（module）

> 在ECMAScript 2015标准里，JavaScript新增了模块的概念。TypeScript也沿用了这个概念。

### 模块的导入和导出
模块在其自身的作用域里执行，而不是在全局作用域里；
这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用export之一导出它们。 
相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用import之一。

模块是自声明的。在TypeScript里，两个模块之间的关系是通过在文件级别上使用import和export建立的。

*demo*
- animal.ts
```typescript
export class Animal {
    name: string;

    show(): string {
        return this.name;
    }

}
```
在animal.ts里声明了一个类Animal，通过export导出
- app.ts
```typescript
import {Animal} from './animal';

let dog = new Animal();
dog.name = '狗狗';
dog.show();
```
在app.ts里，指定相对文件路径，通过import导入，就可以使用Animal类。

> 因为JavaScript存在两种不同的模块引用方式，
在编译成JavaScript时，可以通过TypeScript配置文件tsconfig.json指定编译之后的模块引用方式
- tsconfig.json
```json
{
    "compilerOptions": {
        "target": "es6",
        "noImplicitAny": false,
        "module": "commonjs",       // 模块引用方式。候选值有：commonjs、amd等
        "removeComments": false,
        "sourceMap": false,
        "outDir": "js"
    },
    "include":[
        "ts"
    ],
    "exclude": [
        "js"
    ]
}
```

### 导入和导出的重命名
模块导入和导出时默认使用的内部对象的名称。TypeScript也支持在导出前和导入后进行重命名。

*demo*
- animal.ts
```Typescript
class Animal {
    name: string;
    show(): string {
        return this.name;
    }
}

export {Animal as ANI};
```

- app.ts
```typescript
import {ANI as Animal} from './animal';

let dog = new Animal();
dog.name = '狗狗';
dog.show();
```
导入和导出时，通过as关键字对模块进行重命名。

`注：当导出的模块重命名后，导入时重命名前的模块名要与导出重命名后的模块名保持一致，否则编译器将提示错误信息。
以上面的这个例子为例，导出的模块被重命名为ANI，将此模块在另外一个文件app.ts里导入时，as关键字前面的模块名必须是ANI。`

或者，如果不知道导入模块的名称，则可以用*号代替
```typescript
import * as animal_module from './animal';

let dog = new animal_module.ANI();
dog.name = '狗狗';
dog.show();
```
上面的例子里，对*号代替的所有模块进行重命名为animal_module，则通过animal_module对象可以访问到模块里导出的所有内容。

### 导出和导出多个对象
通常情况，模块里会定义多个类型对象，然后一并导出。而导入的模块里也可能会有多个

*demo*
- animal.ts
```typescript
enum HairColor {
    Golden,
    Black,
    White
}

class Animal {
    name: string;
    color: HairColor;
    show(): string {
        return this.name;
    }
}

export {Animal, HairColor};
```
- app.ts
```typescript
import * as animal_module from './animal';

let dog = new animal_module.Animal();
dog.name = '狗狗';
dog.color = animal_module.HairColor.Golden;
dog.show();
```
导出时，可以将要导出的类型对象重新组装成一个json对象，然后导出。
导入后，可以通过重命名的模块对象访问里面的内容。

### 默认导出
一个模块的默认导出只能有一个

*demo*
- animal.ts
```typescript
class Animal {
    name: string;
    show(): string {
        return this.name;
    }
}

export default Animal;
```
- app.ts
```typescript
import Animal from './animal';

let dog = new Animal();
dog.name = '狗狗';
dog.show();
```
在上面的例子里，通过default关键字，将Animal类导出。
与一般的导入不同的是，导入默认的导出模块时，可以直接指定导入的模块名称，而不需要用{}花括号括起来。

### 动态加载模块
因为在JavaScript里，模块加载方式分别有两种：CommonJS和AMD。
在用TypeScript时，要根据最终编译生成JavaScript的方式的配置内容不同，编写不同的代码。

*demo*
- animal.ts（模版文件）
```typescript
class Animal {
    name: string;
    show(): string {
        return this.name;
    }
}

export {Animal};
```
- CommonJS方式引用：
```typescript
// app.ts 定义加载方法
declare function require(moduleName: string): any;

import {Animal} from './animal';

if (true) {
    let Animal_Type: typeof Animal = require('./animal');
    let dog = new Animal_Type();
    dog.name = '狗狗';
    dog.show();
}
```
- AMD方式引用：
```typescript
// app.ts 定义加载方法
declare function require(moduleNames: string[], onLoad: (...args: any[]) => void): void;

import {Animal} from './animal';

if (true) {
    require(["./animal"], (Animal_Type: typeof Animal) => {
        let dog = new Animal_Type();
        dog.name = '狗狗';
        dog.show();
    });
}
```
