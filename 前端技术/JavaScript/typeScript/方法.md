# 方法（method）

## 方法声明

```Typescript
// 方法求和
function sum(x: number, y: number): number {
    return x + y;
}
// lambda表达式声明
let func_lambda: (x: number, y: number) => number = function (x, y) { return x + y };
```
在TypeScript里，方法声明可以明确定义每一个参数的类型，和返回值的类型。
在编译时，编译器会检查方法体的返回值类型是否符合定义的类型，
同时在调用的时候也会检查传入的参数类型是否符合定义的类型，参数个数是否符合定义的个数。

## 调用方法

```typescript
// 方法求和
function sum(x: number, y: number): number {
    return x + y;
}
// lambda表达式声明
let func_lambda: (x: number, y: number) => number = function (x, y) { return x + y };

let result1 = sum(1, 2);
let result2 = func_lambda(1, 2, 3);           // 错误的调用方式。参数个数多余定义。
let result3 = func_lambda(1);                 // 错误的调用方式。参数个数少于定义。
let result4 = func_lambda('1', '2');          // 错误的调用方式。参数类型不符合定义。
```

## 缺省参数声明

在某些情况下，方法调用只需要传入部分参数。TypeScript也支持缺省参数的声明方式。
```typescript
// 缺省参数定义
let showName = function (firstName: string, lastName?: string): string {
    if (lastName) {
        return firstName + ' ' + lastName;
    } else {
        return firstName;
    }
};

let wholeName1 = showName('星辰', 'Lee');
let wholeName2 = showName('星辰');
```
通过在参数名称后面加上?，标识该参数是缺省的，调用时如果对应参数位置不传入，对应参数位置则为undefined。

## 默认值参数声明

在某些情况下，方法调用时某些参数在不传入时，默认使用方法定义的值。TypeScript同样支持默认值参数的声明方式.
```typescript
// 默认值参数定义
let showName2 = function (firstName: string, lastName = 'Lee'): string {
    return firstName + ' ' + lastName;
};

let wholeName3 = showName2('星辰');
```
通过在参数名称后加上=号并赋值，标识该参数具有默认值。
调用时如果对应参数位置不传入或者传入undefined，则取默认值，否则取对应位置传入的值。

## 多参数声明

像其他强类型语言一样，TypeScript在定义方法的时候，也支持不明数量的多参数传入。
```typescript
// 多参数定义
let restParamsFunc = function (param1: string, ...restParams: string[]): string {
    return param1 + ' ' + restParams.join(' ');
};

let resParamsFuncResult = restParamsFunc('a', 'b', 'c');
```
通过在参入名称前加上...(三个小数点)，标识对应位置的参数可以传入多个。
因为参数类型已明确定义，所以传入的多个参数的类型必须与定义保持一致，否则编译时将提示错误

## 其他类型参数声明

对象类型：
```typescript
// 对象类型参数
let jsonParamFunc = function (x: { p1: string }): string {
    return x.p1;
};

let jsonParamFuncResult1 = jsonParamFunc({ p1: 'a' });              // 赋值类型正确
let jsonParamFuncResult2 = jsonParamFunc({ p1: 'a', p2: 'b' });     // 赋值类型错误，参数属性比定义的多。
let jsonParamFuncResult3 = jsonParamFunc({ p3: 'c' });              // 复制类型错误，参数属性名不匹配。
let params = { p1: 'a', p2: 'b' };
let jsonParamFuncResult4 = jsonParamFunc(params);                   // 用变量代替直接复制，编译器检查通过。
```
上面的例子里，参数类型被定义为一个拥有属性“p1”的json对象。
在方法调用时，传入的参数将严格符合参数类型的定义，
参数对象的属性多余或者少于定义将提示错误，属性名称与定义不一致也将提示错误。

`注：但是，如果传入的是一个变量，变量的属性只要能满足定义的类型属性即可`

方法类型：
```typescript
// 方法类型参数
let funcParamFunc = function (func: (x: string, y: string) => string): string {
    let _x = 'a';
    let _y = 'b';
    return func(_x, _y);
};

let funParamFuncResult = funcParamFunc(function (x, y) { return x + y });
```
方法参数类型可定义为一个固定结构的方法，该方法就成为了一个回调方法。

## 方法重载

TypeScript也支持方法重载。
```typescript
// 方法重载
function overloadFunc(x: { p1: string }): string;
function overloadFunc(x: number): number;
function overloadFunc(x): any {
    if (typeof x == 'object') {
        return x.p1;
    }

    if (typeof x == 'number') {
        return x;
    }
}

let overloadFuncResult1 = overloadFunc({ p1: 'a' });
let overloadFuncResult2 = overloadFunc(1);
```
在上面的例子里，连续声明了拥有同一个名称的三个方法：
前两个方法只有方法定义，没有方法体。它们定义了重载方法的个数和表现形式。
最后一个方法的参数没有定义类型，返回值定义为any，同时有方法体。它定义了重载方法的具体实现。